# Автоматический контроль версий статических файлов

## Как это работает

При каждом `git commit` автоматически инкрементируются версии статических файлов (app.js и styles.css) во всех HTML файлах проекта.

### Пример

**До коммита:**
```html
<script src="static/app.js?v=2" defer></script>
<link rel="stylesheet" href="static/styles.css?v=5" />
```

**После коммита:**
```html
<script src="static/app.js?v=3" defer></script>
<link rel="stylesheet" href="static/styles.css?v=6" />
```

## Компоненты системы

### 1. `increment_version.py`
Python скрипт, который:
- Находит все версии `?v=X` в HTML файлах
- Увеличивает номер версии на 1
- Автоматически добавляет `?v=1` к файлам без версий

### 2. `.git/hooks/pre-commit`
Git hook, который:
- Запускается автоматически перед каждым коммитом
- Вызывает `increment_version.py`
- Добавляет изменённые HTML файлы в текущий коммит

## Использование

### Обычный workflow (автоматический режим)

```bash
# 1. Вносите изменения в код
echo "console.log('new feature')" >> static/app.js

# 2. Коммитите как обычно
git add .
git commit -m "Добавлена новая функция"

# Система автоматически:
# - Увеличит версии в HTML файлах
# - Добавит их в коммит
# - Коммит будет включать и ваши изменения, и обновлённые версии
```

### Ручной запуск (опционально)

Если нужно обновить версии без коммита:

```bash
python increment_version.py
```

## Зачем это нужно?

### Проблема: Кэш браузера

Когда вы обновляете `app.js` или `styles.css`, браузеры пользователей продолжают использовать старые версии из кэша. Изменения не видны до принудительной перезагрузки (Ctrl+F5).

### Решение: Cache Busting

Изменяя URL файла (`app.js?v=2` → `app.js?v=3`), мы заставляем браузер загрузить новую версию:

1. **Старый URL**: `app.js?v=2` (в кэше)
2. **Новый URL**: `app.js?v=3` (не найден в кэше → загружается заново)
3. Сервер отдаёт тот же `app.js`, но браузер кэширует его под новым ключом

## Отключение системы

Если по какой-то причине нужно отключить автоинкремент:

```bash
# Временно отключить pre-commit hook
mv .git/hooks/pre-commit .git/hooks/pre-commit.disabled

# Включить обратно
mv .git/hooks/pre-commit.disabled .git/hooks/pre-commit
```

## Технические детали

### Регулярные выражения

Скрипт ищет паттерны:
- `src="static/app.js?v=X"` - для JavaScript
- `href="static/styles.css?v=X"` - для CSS

### Где применяется

- `index.html` - главная страница
- `calendar.html` - календарь
- `links.html` - полезные ссылки

### Безопасность

- Скрипт работает только с локальными файлами проекта
- Не влияет на удалённый репозиторий до push
- Можно откатить через `git reset` при необходимости

## Проверка работы

После установки системы проверьте:

```bash
# 1. Создайте тестовый коммит
echo "// test" >> static/app.js
git add static/app.js
git commit -m "test"

# 2. Проверьте, что версии увеличились
git diff HEAD~1 index.html

# Вы должны увидеть изменение типа:
# -  <script src="static/app.js?v=3" defer></script>
# +  <script src="static/app.js?v=4" defer></script>
```

## FAQ

**Q: Версии увеличиваются при каждом коммите, даже если app.js не изменился?**
A: Да, это нормально. Альтернативный подход - условное обновление только при изменении файлов, но текущая реализация проще и надёжнее.

**Q: Что делать, если версии "разъехались" между файлами?**
A: Это не проблема. Каждый файл имеет свою версию независимо от других.

**Q: Работает ли на Windows?**
A: Да, скрипт кроссплатформенный. Использует Python и Git Bash (поставляется с Git for Windows).

**Q: Нужно ли коммитить .git/hooks/pre-commit?**
A: Нет, Git hooks не коммитятся автоматически. При клонировании репозитория нужно будет создать hook заново или использовать инструменты типа `husky` (для Node.js проектов).

## Альтернативные подходы

Для production-проектов рекомендуются:

1. **Webpack/Vite** - автоматический хэш в имени файла:
   ```
   app.a3f2b1c.js  # хэш меняется только при изменении содержимого
   ```

2. **CI/CD pipeline** - обновление версий на стадии деплоя

3. **Build timestamp** - использование текущего времени как версии

Для вашего учебного проекта текущая система оптимальна по соотношению простоты и эффективности.
